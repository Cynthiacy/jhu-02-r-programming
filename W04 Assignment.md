R Programming 第四周 Assignment
---

[@生物你好生物再见](http://www.weibo.com/biobyelogy)

---

### 函数 best
1. 数据读取：读入 `csv` 数据。
2. 输入处理：检验输入参数 `state` 的合法性。这里提供两种思路：
 - 手动建立一个包含美国 50 州缩写的 `vector`，检查 `state` 是否存在于这个 `vector` 之中，否则非法输入。
 - 从第一步读入的数据里面提取 `State` 列所有不同的值，这些值就是合法的州缩写，把它们汇集成一个 `vector`，这样就免去人工输入。
3. 输入处理：检验输入参数 `outcome` 的合法性，并根据 `outcome` 的值，确认需要哪一列数据。
4. 数据清理：把原始数据中 `医院名字`、`医院所在州` 和 `outcome 对应的死亡率数据` 提取出来，变成一个新的 `data.frame`。
5. 数据清理：把 `死亡率数据` 一列的数据转换为 `numeric`，去除 `NA`。
6. 数据清理：剔除 `医院所在州` 不等于 `state` 的数据。
7. 数据处理：对清理之后的数据按照 `死亡率数据` 和 `医院名字` 两列降序排序。
8. 结果返回：返回排序后第一家医院。

---

### 函数 rankhospital
- 第 1 步至第 7 步和函数 `best` 完全一样。接下来：
- 输入处理：判断 `num` 的内容，申明一个变量 `return_rank`：
 - 如果是 `best`，`return_rank` 等于 `1`；
 - 如果是 `worst`，`return_rank` 等于第 7 步中排序之后数据列表的总行数；
 - 否则，`return_rank` 就等于 `num`，不过 `num` 是一个 `character`，注意数据类型的转换。
- 结果返回：返回第 7 步中排序之后数据列表的第 `return_rank` 行的医院名字。

---

### 函数 rankall
- 这题最简单粗暴的办法是把每一个州放到函数 `rankhospital` 里面去运行一遍，同时生成一个 `data.frame`。不过这样非常低效，一定要避免，写这种代码以后要被炒鱿鱼的。
- 观察一下以上思路低效的原因是什么，就在于每处理一个州，都有重读一遍数据，并且把其他州的数据过滤掉。解决方法就是用 `split`，把读取的 `csv` 数据分成 50 份，这样每个州的数据分开，节省了重复的操作。

1. 数据读取：读入 `csv` 数据。
2. 输入处理：检验输入参数 `outcome` 的合法性，并根据 `outcome` 的值，确认需要哪一列数据。
3. 数据清理：把原始数据中 `医院名字`、`医院所在州` 和 `outcome 对应的死亡率数据` 提取出来，变成一个新的 `data.frame`，记作 `df`。
4. 数据清理：把 `死亡率数据` 一列的数据转换为 `numeric`，去除 `NA`。
5. 数据处理：用 `split` 把 `df` 按 `State` 分成不同的子表。
6. 结果返回：申明一个空的 `data.frame`，包含 `hospital` 和 `state` 两列。注意使用 `stringsAsFactors=FALSE` 这一选项，非常重要，也要牢记这一选项的意义。
7. 数据处理：用 `for` 循环对每一个州进行处理：
 - 从 `df` 中提取需要的州的子数据集。
 - 对子数据集按照 `死亡率数据` 和 `医院名字` 两列降序排序。
 - 类似第二题，判断 `num` 的内容，提取符合 `num` 输入的 `医院名字`，写入第 6 步中申明的 `data.frame`。
8. 数据返回：返回第 6 步中申明的 `data.frame`。

